<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>高凡</title>
 <link href="http://username.github.com/atom.xml" rel="self"/>
 <link href="http://username.github.com"/>
 <updated>2013-10-27T14:07:06+08:00</updated>
 <id>http://username.github.com</id>
 <author>
   <name>xugaofan</name>
   <email>xugaofan@gmail.com</email>
 </author>

 
 <entry>
   <title>在Mac上重置MySQL的root帐户的密码</title>
   <link href="http://username.github.com/unix/2013/04/11/MAMP-MySQL-on-Mac"/>
   <updated>2013-04-11T00:00:00+08:00</updated>
   <id>hhttp://username.github.com/unix/2013/04/11/MAMP-MySQL-on-Mac</id>
   <content type="html">&lt;p&gt;&lt;strong&gt;最近需要用node操作mysql，但是今天忘记mysql的密码了，需要重置。但是一直不清楚MAMP里面的mysql怎么操作， 今天就花了点时间研究了一下。顺便做一点记录，因为不是经常用，很容易遗忘。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id='mampmysql'&gt;找到MAMP中MySQL的路径&lt;/h2&gt;

&lt;p&gt;一般是在这里：/Applications/MAMP/Library/bin，里面有很多的mysql的bin文件，直接在这个目录操作mysql。&lt;/p&gt;

&lt;h2 id='mysql'&gt;关闭MySQL进程&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;killall -TERM mysqld&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='mysql'&gt;重新启动MySQL&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;./safe_mysqld --skip-grant-tables&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果没有safe_mysqld就使用 mysqld代替&lt;/p&gt;

&lt;h2 id='mysql'&gt;进入MySQL操作数据库&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;./mysql -uroot -p&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样进入数据库就不需要密码了，或者直接打开phpMyAdmin操作数据库&lt;/p&gt;

&lt;h2 id='root'&gt;更新root帐户的密码&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;update user set password=password(&amp;quot;new_pass&amp;quot;) where user=&amp;quot;root&amp;quot;;
flush privileges;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;这样就完成了密码的更改。不过下次使用MAMP启动MySQL的时候，如果无法启动则先使用上面的命令关闭MySQL进程&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;phpMyAdmin的用户名和密码在config.inc.php文件的第85和86行。&lt;/strong&gt;&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Ajax Encoding</title>
   <link href="http://username.github.com/javascript/2012/11/11/Ajax-Encoding"/>
   <updated>2012-11-11T00:00:00+08:00</updated>
   <id>hhttp://username.github.com/javascript/2012/11/11/Ajax-Encoding</id>
   <content type="html">&lt;p&gt;前些天看到一个关于Ajax编码的问题，当时被提问者的描述绕的都想不清楚，今天闲来没事就整理下。原文地址在&lt;a href='http://segmentfault.com/q/1010000000130593'&gt;这里&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id='id42'&gt;问题描述&lt;/h2&gt;

&lt;p&gt;我的前端页面为GBK，所以待发送的数据肯定也为GBK，而由ajax的特性其在发送前其会被自动转换为utf-8 所以后台接收到的数据为utf-8的 然后我的后台页面编码为UTF-8，同时设置了response header中的编码参数也为UTF-8，那么前端收到的数据应该也是UTF-8 但前端页面为GBK，理论上来说这样会产生乱码，可是并没有，这是为什么呢？&lt;/p&gt;

&lt;p&gt;提问者的描述有点混乱，而且各种绕，一不小心就会踩到提问者设的坑。&lt;/p&gt;

&lt;h2 id='id43'&gt;如何解决&lt;/h2&gt;

&lt;p&gt;彻底解决这个问题你首先需要了解以下几个知识点：&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;页面表单提交到后台的数据编码与页面编码一致&lt;/li&gt;
	&lt;li&gt;通过javascript提交到后台的数据都会被转换为utf-8格式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以原则上这样理解，这个问题就差不多了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;输入编码为UTF-8，后台以UTF-8方式输出，保证输入和输出一致那么自然就没有乱码问题。&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要让别人相信自己，首先得自己相信自己，我们先不妨来几个测试。另外问题描述既然提到了后台的文本编码，我们也需要重点测试一下。&lt;/p&gt;

&lt;h2 id='id44'&gt;测试工作&lt;/h2&gt;

&lt;p&gt;准备以下页面：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;主页面index.php&lt;/li&gt;

&lt;li&gt;ajax后台页面utf8.php&lt;/li&gt;

&lt;li&gt;ajax后台页面gbk.php&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id='_indexphpgbk'&gt;主页面 index.php，文本编码gbk&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!docytype html&amp;gt;
&amp;lt;html&amp;gt;
	&amp;lt;head&amp;gt;
		&amp;lt;meta charset=&amp;quot;gbk&amp;quot;/&amp;gt;
		&amp;lt;script src=&amp;quot;http://s.segmentfault.com/js/jquery.js?12.11.5.1&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
	&amp;lt;/head&amp;gt;	
	&amp;lt;body&amp;gt;
		&amp;lt;button type=&amp;quot;button&amp;quot; onclick=&amp;quot;ajax_send(&amp;#39;utf8&amp;#39;)&amp;quot;&amp;gt;JS提交(utf-8)&amp;lt;/button&amp;gt;
		&amp;lt;button type=&amp;quot;button&amp;quot; onclick=&amp;quot;ajax_send(&amp;#39;gbk&amp;#39;)&amp;quot;&amp;gt;JS提交(gbk)&amp;lt;/button&amp;gt;
		&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
			var ajax_send = function(encoding){
				var xhr = new XMLHttpRequest(), params = encodeURI(&amp;#39;t=编码&amp;#39;)
				xhr.onreadystatechange = function(){
					if(this.readyState == 4 &amp;amp;&amp;amp; this.status ==200)
						alert(this.responseText)
				}
				xhr.open(&amp;#39;POST&amp;#39;,encoding + &amp;#39;.php&amp;#39;,true)
				xhr.setRequestHeader(&amp;quot;Content-type&amp;quot;, &amp;quot;application/x-www-form-urlencoded&amp;quot;);
				xhr.send(params)
			}
		&amp;lt;/script&amp;gt;
	&amp;lt;/body&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='utf8phputf8'&gt;utf8.php，文本编码utf-8&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php
header(&amp;#39;content-type:text/html;charset=utf-8&amp;#39;);
echo $_POST[&amp;#39;t&amp;#39;];
?&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='gbkphputf8phpgbk'&gt;gbk.php，与utf8.php内容相同，区别就是文本编码为gbk&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php
header(&amp;#39;content-type:text/html;charset=utf-8&amp;#39;);
echo $_POST[&amp;#39;t&amp;#39;];
?&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动Web Server，打开页面，分别点击按钮，都正确的弹出了“编码”二字，没有发现乱码现象。&lt;/p&gt;

&lt;h2 id='id45'&gt;结论&lt;/h2&gt;

&lt;p&gt;对于页面通过JS提交的数据：&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;后台接口，只要保证输入输出的编码一致，提交的数据就会有乱码产生&lt;/li&gt;
	&lt;li&gt;后台文件的文本编码以及前端页面的编码不会导致提交的数据返回时乱码，只要输入输出编码一致&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于以上两个结论，读者还可以这样测试。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php
header(&amp;#39;content-type:text/html;charset=gbk&amp;#39;);
echo iconv(&amp;quot;utf-8&amp;quot;,&amp;quot;gbk&amp;quot;,$_POST[&amp;#39;t&amp;#39;]);
?&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先将输入转码为gbk，然后输出同时设置为页面编码，这样也不会有乱码产生，但是服务端多了一道转码处理，效率不及直接输出utf-8。&lt;/p&gt;

&lt;p&gt;对于后台附加的一些输出，比如在gbk.php中最后加一行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo &amp;quot;中文&amp;quot;;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种情况会不会导致乱码呢？读者可以自己测试一下。&lt;/p&gt;

&lt;h2 id='id46'&gt;深入&lt;/h2&gt;

&lt;p&gt;稍微搞过前端的人都知道，使用script标签引入脚本的时候，有一个属性是charset用于指定脚本文件的编码。当页面编码与引入脚本的文本编码不一致的时候需要显式指定，否则就会容易造成乱码。&lt;/p&gt;

&lt;p&gt;现在我们仔细对比这两种场景的处理方式，不就是一模一样吗？只要保证输入输出的编码一致即可。唯一的区别就是一个是静态资源，一个是动态接口。&lt;/p&gt;

&lt;p&gt;你有可能会问，当输入输出指定的编码不一致时是不是就一定是乱码呢，浏览器又该如何解析呢？&lt;/p&gt;

&lt;p&gt;这个时候你就该来&lt;a href='http://ued.taobao.com/blog/2011/08/26/encode-war/'&gt;这里&lt;/a&gt;看看了。&lt;/p&gt;

&lt;p&gt;光棍节写博客，看来我是真光棍，真屌丝。&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>iOS UIWebView Class Reference</title>
   <link href="http://username.github.com/javascript/2012/10/30/iOS-UIWebView-Class-Reference"/>
   <updated>2012-10-30T00:00:00+08:00</updated>
   <id>hhttp://username.github.com/javascript/2012/10/30/iOS-UIWebView-Class-Reference</id>
   <content type="html">&lt;p&gt;&lt;a href='https://developer.apple.com/library/ios/#documentation/UIKit/Reference/UIWebView_Class/Reference/Reference.html'&gt;原文地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id='id40'&gt;属性&lt;/h2&gt;

&lt;h3 id='allowsinlinemediaplayback'&gt;allowsInlineMediaPlayback&lt;/h3&gt;
&lt;strong style='color:red;'&gt;前端重点关注&lt;/strong&gt;
&lt;p&gt;是否允许页内播放视频，默认值NO，使用原生的全屏控制。&lt;/p&gt;

&lt;p&gt;使用页面播放需要设置此属性为YES，并且video 元素要加上 &lt;code&gt;webkit-playsinline&lt;/code&gt;属性。&lt;/p&gt;

&lt;h3 id='cangoback'&gt;canGoBack&lt;/h3&gt;

&lt;p&gt;是否可以后退，只读属性&lt;/p&gt;

&lt;h3 id='cangoforward'&gt;canGoForward&lt;/h3&gt;

&lt;p&gt;是否可以前进，只读属性&lt;/p&gt;

&lt;h3 id='datadetectortypes'&gt;dataDetectorTypes&lt;/h3&gt;

&lt;p&gt;在webview被转换为可点击的URL内容的数据类型。&lt;/p&gt;

&lt;p&gt;使用此属性可以指定譬如&lt;code&gt;http链接&lt;/code&gt;，&lt;code&gt;Email地址&lt;/code&gt;，&lt;code&gt;电话号码&lt;/code&gt;等内容将自动转换为可点击的链接。当点击以后，webview寻找相应的应用程序来处理。&lt;/p&gt;

&lt;h3 id='delegate'&gt;delegate&lt;/h3&gt;

&lt;p&gt;委托，用于回调通知页面的加载状态，比如已经打开、打开完成或打开错误等。&lt;/p&gt;

&lt;h3 id='keyboarddisplayrequiresuseraction'&gt;keyboardDisplayRequiresUserAction&lt;/h3&gt;
&lt;strong style='color:red;'&gt;前端重点关注&lt;/strong&gt;
&lt;p&gt;显示键盘是否一定需要用户动作，默认值为YES，也就是用户必须主动点击可输入的表单元素以后才会显示键盘。&lt;/p&gt;

&lt;p&gt;设置为NO以后，页面可以通过JS脚本的&lt;code&gt;focus&lt;/code&gt;事件显示键盘。&lt;/p&gt;

&lt;h3 id='loading'&gt;loading&lt;/h3&gt;

&lt;p&gt;webview是否还在加载，只读属性&lt;/p&gt;

&lt;h4 id='mediaplaybackallowsairplay'&gt;mediaPlaybackAllowsAirPlay&lt;/h4&gt;
&lt;strong style='color:red;'&gt;前端重点关注&lt;/strong&gt;
&lt;p&gt;媒体播放是否允许&lt;code&gt;Air Play&lt;/code&gt;???默认值为YES&lt;/p&gt;

&lt;h3 id='mediaplaybackrequiresuseraction'&gt;mediaPlaybackRequiresUserAction&lt;/h3&gt;
&lt;strong style='color:red;'&gt;前端重点关注&lt;/strong&gt;
&lt;p&gt;媒体播放是否需要用户动作主动触发，默认值为YES。也就是说默认情况无法自动播放音频和视频。&lt;/p&gt;

&lt;p&gt;那么默认设置下是不是一定无法自动播放呢？StackOverflow上找到一个&lt;a href='http://stackoverflow.com/questions/4259928/how-can-i-autoplay-media-in-ios-4-2-1-mobile-safari'&gt;方法&lt;/a&gt;解决此问题（没有测试）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var ifr = document.createElement(&amp;quot;iframe&amp;quot;);
ifr.setAttribute(&amp;#39;src&amp;#39;, &amp;quot;http://mysite.com/myvideo.mp4&amp;quot;);
ifr.setAttribute(&amp;#39;width&amp;#39;, &amp;#39;1px&amp;#39;);
ifr.setAttribute(&amp;#39;height&amp;#39;, &amp;#39;1px&amp;#39;);
ifr.setAttribute(&amp;#39;scrolling&amp;#39;, &amp;#39;no&amp;#39;);
ifr.style.border=&amp;quot;0px&amp;quot;;
document.body.appendChild(ifr);&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='request'&gt;request&lt;/h3&gt;

&lt;p&gt;webview当前请求的URL，只读属性&lt;/p&gt;

&lt;h3 id='scalespagetofit'&gt;scalesPageToFit&lt;/h3&gt;

&lt;p&gt;指定页面是否按比例缩放适应webview，并且用户可以更改缩放比例。默认值为NO，用户不能更改缩放比例。&lt;/p&gt;

&lt;h3 id='scrollview'&gt;scrollView&lt;/h3&gt;

&lt;p&gt;webview关联的scroll view，只读属性&lt;/p&gt;

&lt;h3 id='suppressesincrementalrendering'&gt;suppressesIncrementalRendering&lt;/h3&gt;

&lt;p&gt;当页面完全加载到内存以后，webview是否禁止增量内容渲染，默认值为NO&lt;/p&gt;

&lt;p&gt;iOS 6.0版本支持&lt;/p&gt;

&lt;h2 id='id41'&gt;实例方法&lt;/h2&gt;

&lt;h3 id='goback'&gt;goBack&lt;/h3&gt;

&lt;p&gt;加载历史记录当前页之前的页面&lt;/p&gt;

&lt;h3 id='goforward'&gt;goForward&lt;/h3&gt;

&lt;p&gt;加载历史记录当前页之后的页面&lt;/p&gt;

&lt;h3 id='loaddatamimetypetextencodingnamebaseurl'&gt;loadData:MIMEType:textEncodingName:baseURL&lt;/h3&gt;

&lt;p&gt;设置页面内容，MIMIE type，编码，URL&lt;/p&gt;

&lt;h3 id='loadhtmlstringbaseurl'&gt;loadHTMLString:baseURL:&lt;/h3&gt;

&lt;p&gt;设置页面内容&lt;/p&gt;

&lt;h3 id='loadrequest'&gt;loadRequest&lt;/h3&gt;

&lt;p&gt;根据指定的URL进行异步连接&lt;/p&gt;

&lt;h3 id='reload'&gt;reload&lt;/h3&gt;

&lt;p&gt;重新载入当前页&lt;/p&gt;

&lt;h3 id='stoploading'&gt;stopLoading&lt;/h3&gt;

&lt;p&gt;取消当前页的加载&lt;/p&gt;

&lt;h3 id='stringbyevaluatingjavascriptfromstring'&gt;stringByEvaluatingJavaScriptFromString&lt;/h3&gt;
&lt;strong style='color:red;'&gt;前端重点关注&lt;/strong&gt;
&lt;p&gt;在页面加载完成以后运行JavaScript脚本，运行脚本有如下注意事项：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;脚本运行不得超过10秒&lt;/li&gt;

&lt;li&gt;将要执行的脚本内存分配不得超过10M&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href='http://url.cn/7Vf4bx'&gt;这里&lt;/a&gt;有一个比较详细的教程可以参考&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>A Cross Domain Practice</title>
   <link href="http://username.github.com/javascript ruby sinatra/2012/07/27/A-Cross-Domain-Practice"/>
   <updated>2012-07-27T00:00:00+08:00</updated>
   <id>hhttp://username.github.com/javascript ruby sinatra/2012/07/27/A-Cross-Domain-Practice</id>
   <content type="html">&lt;h2 id='id30'&gt;项目需求&lt;/h2&gt;

&lt;p&gt;对一个照片列表页面的每张图片在前端进行下载耗时统计，并定期上报。&lt;/p&gt;

&lt;h2 id='id31'&gt;基本思路&lt;/h2&gt;

&lt;p&gt;使用&lt;code&gt;XMLHttpRequest&lt;/code&gt;下载图片，实现下载耗时统计。上报功能则一次上报&lt;code&gt;localStorage&lt;/code&gt;存储的多张图片的统计信息，这里不做讨论&lt;/p&gt;

&lt;h2 id='id32'&gt;问题难点&lt;/h2&gt;

&lt;p&gt;使用&lt;code&gt;XMLHttpRequest&lt;/code&gt;需要跨域访问图片服务器&lt;/p&gt;

&lt;h2 id='id33'&gt;其它说明&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;项目只服务于移动终端，本文的一切测试原则上只涉及&lt;code&gt;Webkit&lt;/code&gt;系列的浏览器&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为了方便快捷地看到效果，后台使用&lt;code&gt;Ruby&lt;/code&gt;语言的轻量级框架&lt;code&gt;Sinatra&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用&lt;code&gt;127.0.0.1&lt;/code&gt;访问&lt;code&gt;localhost&lt;/code&gt;模拟跨域图片请求&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id='id34'&gt;项目文件&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;前端测试主页面 &lt;code&gt;test.html&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;后台请求处理文件 &lt;code&gt;myapp.rb&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一张测试图片 &lt;code&gt;london.jpg&lt;/code&gt;，大小47714B&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id='id35'&gt;代码预览&lt;/h2&gt;

&lt;h3 id='testhtml'&gt;test.html&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;```html
&amp;lt;!doctype html&amp;gt;
&amp;lt;html lang=&amp;quot;zh-CN&amp;quot;&amp;gt;
	&amp;lt;head&amp;gt;
		&amp;lt;meta charset=&amp;quot;utf-8&amp;quot; /&amp;gt;
	&amp;lt;/head&amp;gt;
	&amp;lt;body&amp;gt;
		&amp;lt;h1&amp;gt;跨域获取图片的文件大小&amp;lt;/h1&amp;gt;
		&amp;lt;button id=&amp;quot;send&amp;quot;&amp;gt;Send Ajax Request&amp;lt;/button&amp;gt;
		&amp;lt;script&amp;gt;
			+function(){
				var xhr = new XMLHttpRequest(),
					host = location.href.indexOf(&amp;#39;localhost&amp;#39;)&amp;gt;-1?&amp;#39;127.0.0.1&amp;#39;:&amp;#39;localhost&amp;#39;,
					url = &amp;#39;http://&amp;#39; + host + &amp;#39;:4567/img&amp;#39;
				xhr.onload  = function(e){
					console.log(e)
				}
				xhr.onerror = function(a){
					console.log(a)
				}
				var send = document.getElementById(&amp;#39;send&amp;#39;)
				send.addEventListener(&amp;#39;click&amp;#39;,function(){
					xhr.abort()
					xhr.open(&amp;#39;GET&amp;#39;, url, true)
					xhr.send(null)
				},false)
			}()
		&amp;lt;/script&amp;gt;
```&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='myapprb'&gt;myapp.rb&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;```ruby
# myapp.rb
require &amp;#39;rubygems&amp;#39;
require &amp;#39;sinatra&amp;#39;

get &amp;#39;/&amp;#39; do
	send_file &amp;#39;test.html&amp;#39;
end

#跨域请求
get &amp;#39;/img&amp;#39; do
	send_file &amp;#39;london.jpg&amp;#39;
end
```&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id36'&gt;开始工作&lt;/h2&gt;

&lt;p&gt;启动web server以后就开始我们的测试工作了。打开&lt;code&gt;chrome&lt;/code&gt;及其&lt;code&gt;控制台&lt;/code&gt;，输入 http://localhost:4567/，点击页面中的按钮，不出意外你会在chrome控制台看到下面的错误提示。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;XMLHttpRequest cannot load http://127.0.0.1:4567/img. Origin http://localhost:4567 is not allowed by Access-Control-Allow-Origin.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;因为我们对跨域访问没有进行任何设置，所以自然无法通过浏览器内在的&lt;code&gt;同源安全机制&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id='id37'&gt;实现跨域访问&lt;/h2&gt;

&lt;p&gt;google如何实现跨域访问，很快找到了一种方法。在网站根目录放置&lt;code&gt;crossdomain.xml&lt;/code&gt;的配置文件，就可以完美地实现跨域访问。难怪qq.com和taobao.com都不约而同的配置了这个文件，该文件的格式一般如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;cross-domain-policy&amp;gt;
	&amp;lt;allow-access-from domain=&amp;quot;*.site.com&amp;quot;/&amp;gt;
	&amp;lt;allow-access-from domain=&amp;quot;*.site.net&amp;quot;/&amp;gt;
	&amp;lt;allow-access-from domain=&amp;quot;*.sitecdn.com&amp;quot;/&amp;gt;
&amp;lt;/cross-domain-policy&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;经过一番测试，发现这样还是无法实现跨域访问。后来终于知道crossdomain.xml文件是flash跨域专用，而且据说已经被Adobe公司申请为专利。看来这条路是走不通了。&lt;/p&gt;

&lt;p&gt;于是继续google，终于在&lt;a href='http://www.w3.org/TR/cors/'&gt;这里&lt;/a&gt;看到了一切关于我们想要的。，可惜&lt;code&gt;w3c&lt;/code&gt;的文档总是那么地冗长而乏味，令人望而生畏。比如在介绍这个&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;的响应头如何设置时，看着这里的介绍是&amp;#8221; origin-list-or-null | &amp;#8221;&lt;em&gt;&amp;#8220;，我以为可以一次性设置多个origin，比如 a.com,b.com,c.com。一番折腾之后发现这样设置和没有设置是一样的效果，如果不设置为星号就只能设置一个站点。那我们就暂时设置为&amp;#8221;&lt;/em&gt;&amp;#8220;吧，安全问题稍后再考虑！修改我们的后台代码，加入一个全局的&lt;code&gt;过滤器&lt;/code&gt;设置响应头，下面是修改后的myapp.rb文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;```ruby
# myapp.rb
require &amp;#39;rubygems&amp;#39;
require &amp;#39;sinatra&amp;#39;

get &amp;#39;/&amp;#39; do
	send_file &amp;#39;test.html&amp;#39;
end

#跨域请求
get &amp;#39;/img&amp;#39; do
	send_file &amp;#39;london.jpg&amp;#39;
end

after do
	headers\
	&amp;#39;Access-Control-Allow-Origin&amp;#39; =&amp;gt; &amp;#39;*&amp;#39;
end
```&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在我们重启web server和浏览器，继续输入http://localhost:4567/，点击页面中的按钮发起跨域请求，查看crhome控制台，没有发现错误，请求顺利完成。那就让我们看看&lt;code&gt;Network&lt;/code&gt;中的跨域访问请求到底多了些什么：&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Access-Control-Allow-Origin:&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Connection:Keep-Alive&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Content-Length:47714&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Content-Type:image/jpeg&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Date:Fri, 27 Jul 2012 07:11:42 GMT&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Last-Modified:Fri, 27 Jul 2012 02:52:45 GMT&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Server:WEBrick/1.3.1 (Ruby/1.8.7/2011-12-28)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;X-Frame-Options:sameorigin&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;X-Xss-Protection:1; mode=block&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;果然我们设置的响应头&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;生效了，太神奇了！通过服务器和浏览器的协作，我们轻松地实现了跨域访问。现在看来W3C搞的这些跨域访问控制的标准还是比较靠谱的啊，如果说有什么缺点，那就是设置多个站点的时候麻烦了点（比如qq.com需要配置跨域访问控制的话），其它的缺点一时我还真说不出来。&lt;/p&gt;

&lt;h2 id='id38'&gt;读取图片的文件大小&lt;/h2&gt;

&lt;p&gt;目前为止，我们算是成功地实现了跨域请求，但是离我们的目标还差一点。我们还需要知道这个图片的文件大小，从之前服务器输出的响应头来看，应该就是&lt;code&gt;Content-Length&lt;/code&gt;这个响应头了。那就修改下我们的页面代码，获取这个响应头吧：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;```html
&amp;lt;!doctype html&amp;gt;
&amp;lt;html lang=&amp;quot;zh-CN&amp;quot;&amp;gt;
	&amp;lt;head&amp;gt;
		&amp;lt;meta charset=&amp;quot;utf-8&amp;quot; /&amp;gt;
	&amp;lt;/head&amp;gt;
	&amp;lt;body&amp;gt;
		&amp;lt;h1&amp;gt;跨域获取图片的文件大小&amp;lt;/h1&amp;gt;
		&amp;lt;button id=&amp;quot;send&amp;quot;&amp;gt;Send Ajax Request&amp;lt;/button&amp;gt;
		&amp;lt;script&amp;gt;
			+function(){
				var xhr = new XMLHttpRequest(),
					host = location.href.indexOf(&amp;#39;localhost&amp;#39;)&amp;gt;-1?&amp;#39;127.0.0.1&amp;#39;:&amp;#39;localhost&amp;#39;,
					url = &amp;#39;http://&amp;#39; + host + &amp;#39;:4567/img&amp;#39;
				xhr.onload  = function(e){
					console.log(this.getResponseHeader(&amp;#39;Content-Length&amp;#39;))
					console.log(this.responseText.length)
				}
				xhr.onerror = function(a){
					console.log(a)
				}
				var send = document.getElementById(&amp;#39;send&amp;#39;)
				send.addEventListener(&amp;#39;click&amp;#39;,function(){
					xhr.abort()
					xhr.open(&amp;#39;GET&amp;#39;, url, true)
					xhr.send(null)
				},false)
			}()
		&amp;lt;/script&amp;gt;
```&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;刷新页面，打开控制台，点击按钮，一个红色的错误呈现在我们眼前：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Refused to get unsafe header &amp;quot;Content-Length&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;怎么样让浏览器服软允许脚本获取这个响应头呢？还是继续去w3c的文档找找吧。很幸运，这个&lt;code&gt;Access-Control-Expose-Headers&lt;/code&gt;似乎和我们的需求很匹配啊，不妨在过滤器中加入输出这个响应头来试一试：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# myapp.rb
require &amp;#39;rubygems&amp;#39;
require &amp;#39;sinatra&amp;#39;

get &amp;#39;/&amp;#39; do
	send_file &amp;#39;test.html&amp;#39;
end

#跨域请求
get &amp;#39;/img&amp;#39; do
	send_file &amp;#39;london.jpg&amp;#39;
end

after do
	headers\
	&amp;#39;Access-Control-Allow-Origin&amp;#39; =&amp;gt; &amp;#39;*&amp;#39;,
	&amp;#39;Access-Control-Expose-Headers&amp;#39; =&amp;gt; &amp;#39;Content-Length&amp;#39;
end&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重启web server，刷新页面，打开chrome控制台，点击按钮。没有任何错误，顺利输出两个数值：47714，45926。看来已经能够顺利的获取到Content-Length响应头，而且数值也很准确，和文件大小一致。但是这个&lt;code&gt;responseText&lt;/code&gt;为什么少了接近2KB呢？还请高人解答。&lt;/p&gt;

&lt;p&gt;一切都很顺利，不过虽然只针对webkit系浏览器，至少也得测试下safari吧。打开safari及其控制台，输入url，点击按钮，居然抛出了和之前未设置&lt;code&gt;Access-Control-Expose-Headers&lt;/code&gt;时一样的错误：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Refused to get unsafe header &amp;quot;Content-Length&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;是不是浏览器缓存的问题呢？重启浏览器再测试，问题依旧。看来这应该就是safari的bug了。既然safari不支持，那就意味着我们前端脚本无法使用&lt;code&gt;getResponseHeader&lt;/code&gt;了，那问题该如何解决呢？让我们再看看w3c上关于&lt;code&gt;XMLHttpRequest Level 2&lt;/code&gt;的实现还有属性和函数我们可能用得上，继续找啊&amp;#8230;终于发现XMLHttpRequest Level 2有一个&lt;a href='http://www.w3.org/TR/XMLHttpRequest2/#handler-xhr-onprogress'&gt;onprogress&lt;/a&gt;事件和&lt;a href='http://dvcs.w3.org/hg/progress/raw-file/tip/Overview.html#progressevent'&gt;ProgressEvent&lt;/a&gt;对象，于是修改我们的页面代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!doctype html&amp;gt;
&amp;lt;html lang=&amp;quot;zh-CN&amp;quot;&amp;gt;
	&amp;lt;head&amp;gt;
		&amp;lt;meta charset=&amp;quot;utf-8&amp;quot; /&amp;gt;
	&amp;lt;/head&amp;gt;
	&amp;lt;body&amp;gt;
		&amp;lt;h1&amp;gt;跨域获取图片的文件大小&amp;lt;/h1&amp;gt;
		&amp;lt;button id=&amp;quot;send&amp;quot;&amp;gt;Send Ajax Request&amp;lt;/button&amp;gt;
		&amp;lt;script&amp;gt;
			+function(){
				var xhr = new XMLHttpRequest(),
					host = location.href.indexOf(&amp;#39;localhost&amp;#39;)&amp;gt;-1?&amp;#39;127.0.0.1&amp;#39;:&amp;#39;localhost&amp;#39;,
					url = &amp;#39;http://&amp;#39; + host + &amp;#39;:4567/img&amp;#39;
				xhr.onprogress  = function(e){
					if(e.lengthComputable){
						if(e.loaded/e.total == 1){
							//invoke onload
							console.log(e.total)
						}
					}
				}
				xhr.onerror = function(a){
					console.log(a)
				}
				var send = document.getElementById(&amp;#39;send&amp;#39;)
				send.addEventListener(&amp;#39;click&amp;#39;,function(){
					xhr.abort()
					xhr.open(&amp;#39;GET&amp;#39;, url, true)
					xhr.send(null)
				},false)
			}()
		&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;细心的同学可能会问为什么不在&lt;code&gt;onload&lt;/code&gt;中执行相关操作，其实经我测试发现onload之后&lt;code&gt;e.total&lt;/code&gt;和&lt;code&gt;e.loaded&lt;/code&gt;已经被设置为0，虽然&lt;code&gt;responseText&lt;/code&gt;依然可读，但是这与真实的文件大小有一点的误差。&lt;/p&gt;

&lt;h2 id='id39'&gt;最后的完善&lt;/h2&gt;

&lt;p&gt;虽然我们的目标已经完成，但是我们的工作还没有结束。因为服务端存在一个严重的&lt;code&gt;安全隐患&lt;/code&gt;。我们草率地将&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;设置为”＊“，不可避免地为一些黑客攻击创造了便利条件。&lt;/p&gt;

&lt;p&gt;其实，既然我们的跨域访问只开放给部分信任的站点，那么我们只需要在后台的过滤器中判断请求来源是否属于白名单之中，如果存在则输出Access-Control-Allow-Origin响应头，内容为该站点域名。至于这个白名单的设计，可以参考&lt;code&gt;Apache&lt;/code&gt;（之前一直误以为Apache的做法是业界的标准）。&lt;/p&gt;

&lt;p&gt;另外跨域访问控制一般针对的是Ajax请求，所以我们还可以在过滤器中加入一个是否是Ajax请求的判断(服务端判断请求头中是否包含&lt;code&gt;X-Requested-With&lt;/code&gt;:&lt;code&gt;XMLHttpRequest&lt;/code&gt;)，避免为普通的请求也加入&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;这个响应头。&lt;/p&gt;

&lt;p&gt;最后由于各浏览器对&lt;code&gt;Access-Control-Expose-Headers&lt;/code&gt;的实现并不完善，所以这个响应头就显得异常鸡肋。&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Disaster Tolerant in JavaScript</title>
   <link href="http://username.github.com/javascript/2012/03/28/Disaster-Tolerant-in-JavaScript"/>
   <updated>2012-03-28T00:00:00+08:00</updated>
   <id>hhttp://username.github.com/javascript/2012/03/28/Disaster-Tolerant-in-JavaScript</id>
   <content type="html">&lt;h2 id='id22'&gt;应用场景&lt;/h2&gt;

&lt;p&gt;存在轮询的AJAX或者JSONP跨域请求的Web应用。&lt;/p&gt;

&lt;p&gt;比如我们有两台服务器，分别是a.com和a-bk.com，默认的轮询请求使用a.com；&lt;/p&gt;

&lt;p&gt;当a.com由于某种原因无法访问，需要按照一种事先约定的机制，将后续请求指向到备用服务器。&lt;/p&gt;

&lt;p&gt;同时当主服务器正常时，立即切换到主服务器。&lt;/p&gt;

&lt;h2 id='id23'&gt;现实项目&lt;/h2&gt;

&lt;p&gt;在我们的应用中，JSONP轮询的频率是每十秒一次。由于移动机房经常性的故障，导致客户长时间不能正常访问。&lt;/p&gt;

&lt;p&gt;于是客户经常向我们报障，试想如果此时，前端能够将用户的后续访问切换到我们的电信服务器，那该多好啊！&lt;/p&gt;

&lt;p&gt;虽然响应会慢一些，但是至少整个系统处于可用状态。&lt;/p&gt;

&lt;h2 id='id24'&gt;容灾机制&lt;/h2&gt;

&lt;p&gt;经过和同事们的一番讨论最后确定我们的容灾机制：&lt;/p&gt;

&lt;p&gt;连续两次请求没有及时应答则认定当前服务器不可用，切换到备用服务器；&lt;/p&gt;

&lt;p&gt;同时发起一个定时器，每55秒检测主服务器是否可用（访问主服务器上的一张43b的图片），一旦可用，立刻切换到主服务器。&lt;/p&gt;

&lt;h2 id='id25'&gt;实现逻辑&lt;/h2&gt;

&lt;p&gt;确定好容灾机制以后，剩下的就是编码了。&lt;/p&gt;

&lt;p&gt;不过编码之前其实还有一个隐藏的重大问题，那就是我们如何确定这个请求是否超时？&lt;/p&gt;

&lt;p&gt;因为我们的跨域JSONP请求都是使用script tag，而且需要兼容IE 6,自然没有什么类似的ontimeout事件去检测。&lt;/p&gt;

&lt;p&gt;那我们就只有自己动手来处理了。&lt;/p&gt;

&lt;p&gt;对于单个请求超时的判断，我们可以在主函数启动时设置一个状态量为false，回调函数中修改这个值为true。&lt;/p&gt;

&lt;p&gt;由于需要尽量避免修改原函数逻辑，这里用到了 &lt;code&gt;AOP&lt;/code&gt; 技术，详细参见&lt;a href='http://xugaofan.github.com/javascript/2012/03/18/AOP-in-JavaScript/'&gt;这里&lt;/a&gt;&lt;/p&gt;

&lt;h3 id='id26'&gt;方案一&lt;/h3&gt;

&lt;p&gt;每一次发起JSONP请求后，开启一个setTimeout 8秒后去检测状态量是否被修改（变量由回调函数修改），依此判断响应成功与否。&lt;/p&gt;

&lt;h3 id='id27'&gt;方案二&lt;/h3&gt;

&lt;p&gt;建立一个对象，给每一次请求标记ID，将其使用的服务器地址和响应结果记录下来；&lt;/p&gt;

&lt;p&gt;在第N次请求发起之前，判断第N-2次和N-1次请求是否使用相同的服务器，如果是，当这两次请求都没有及时响应时切换到备用服务器。&lt;/p&gt;

&lt;h3 id='id28'&gt;比较结果&lt;/h3&gt;

&lt;p&gt;方案一对每次请求都在下一次轮询之前就决定它是成功还是失败。我在生产中设置的值是6.5秒，但发现许多客户经常在主服务器和备用服务器上来回切换。&lt;/p&gt;

&lt;p&gt;方案二的好处在于，首先没有发起额外的setTimeout来监测请求成功是否响应，其次对于每一次请求方案二的超时时间实际是一个动态的值。&lt;/p&gt;

&lt;p&gt;对比下就知道方案一对每个请求的超时容忍度都是相同的6.5秒，最大也只能是10秒，而方案二第N-2次的超时容忍时间是20秒，第N-1次是10秒。&lt;/p&gt;

&lt;p&gt;所以严格意义上来讲，方案二更宽容也更加合理。&lt;/p&gt;

&lt;h2 id='id29'&gt;编码实现&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;/**
* @description 网络模块
* @property {Number} DETECT_CYCLE 切换到备用服务器后，监测主域名的周期，单位为秒，周期长度最好不要设置为10的倍数，便于调试观察
*/
_.net = { DETECT_CYCLE:55 };
/**
* @description 为跨域请求函数注入容灾备份机制，需要将原函数的请求服务器地址改成_.net[&amp;#39;funcname_current_server&amp;#39;];
* 实现原理：使用对象存储每一次请求使用的服务器地址和请求结果，然后在每一次请求之前，判断前两次使用相同服务器的请求是否都不成功。
* 如果都不成功表明连续两次请求失败则切换到备用服务器
* @param {Object} entry 入口函数{context:执行环境,name:函数名称}
* @param {Object} exit 回调函数{context:执行环境,name:函数名称}
* @param {Object} settings 服务端配置{server:主域地址,backupServer:备选服务器地址，数组，长度为0则不启用容灾机制,serverImg:监测主域名可用的图片}
* @param {Function} forward 动态判断是否在入口函数继续执行注入的容灾机制
* @usage 参见/user/js/map.js
* @dependacy {Function} _.inject
*/
_.net.backup = function(entry,exit,settings,forward){
	var server = settings.server,currentServer = entry.name + &amp;#39;_current_server&amp;#39;;
	_.net[currentServer] = server;
	//没有备用地址则不启动容灾备份机制
	if(!settings.backupServer || !_.isArray(settings.backupServer) || !settings.backupServer.length) return;
	var interval = entry.name + &amp;#39;_interval&amp;#39;,//切换到备用以后发起定时器key_name
		total = entry.name + &amp;#39;_total&amp;#39;,//总的请求次数key_name
		status = entry.name + &amp;#39;_status&amp;#39;,//维护各次请求的地址和请求结果key_name
		serverAvailable = entry.name + &amp;#39;_server_available&amp;#39;;//表明当前主服务器是否可用的key_name
	//主服务器可用时立即切换，并重置对应的变量
	var resetServer = function(){
		_.net[serverAvailable] = true;
		_.net[currentServer] = server;
		clearInterval(_.net[interval]);
	};
	//筛选服务器算法，如果当前使用主服务器则切换到备用，如果已经是备用，有多个备用时则切换到下一个备用，只有一个备用是切换到主服务器
	var selectServer = function(){
		if(_.net[currentServer] == server){
			return settings.backupServer[0];
		}else{
			var len = settings.backupServer.length;
			if(len ==1)
				return server;
			var index = _.indexOf(settings.backupServer,_.net[currentServer]);
			return settings.backupServer[index+1] || settings.backupServer[0];
		}
	};
	_.net[serverAvailable] = true;
	_.net[interval] = null;
	_.net[total] = 0;
	_.net[status] = {};//格式：{1:[&amp;#39;http://a.net/&amp;#39;,true], 2:[&amp;#39;http://a.net/&amp;#39;]}
	entry.start = function(){
		if(typeof forward == &amp;#39;function&amp;#39;){
			if(!forward())return;
		}
		_.net[total] += 1;
		var count = _.net[total];
		//存储当此请求使用的服务器地址和响应结果
		_.net[status][count-1] = [];
		if(count &amp;gt; 2){
			var prev = _.net[status][count-2], prevPrev = _.net[status][count-3];
			//上两次请求使用同一个服务器且都失败了，则切换服务器
			if(prev[0] == prevPrev[0] &amp;amp;&amp;amp; !prev[1] &amp;amp;&amp;amp; !prevPrev[1]){
				var usingServer = _.net[currentServer] == server, old = _.net[currentServer];
				if(usingServer){
					_.net[interval] = setInterval(function(){ 
						var img = new Image();
						img.onload = resetServer;
						img.src = settings.serverImg + (settings.serverImg.indexOf(&amp;#39;?&amp;#39;)&amp;gt;-1?&amp;#39;&amp;amp;&amp;#39;:&amp;#39;?&amp;#39;) + &amp;#39;t=&amp;#39; + new Date().getTime();
					}, _.net.DETECT_CYCLE*1000);
				}
				//如果只有一个备用服务器且备用不可用则立即切换到tbo
				if(!usingServer &amp;amp;&amp;amp; settings.backupServer.length==1){
					resetServer();
				}else{
					_.net[currentServer] = selectServer(_.net[currentServer]);
					_.net[serverAvailable] = _.net[currentServer] == server;
				}
				if(settings.errorHandler){
					settings.errorHandler(old,_.net[currentServer]);
				}
			}else{
				//如果备用服务器一直正常，那么需要一直检测主域名是否可用，如果可用立即切换到主域名
				if(_.net[currentServer] != server){
					if(_.net[serverAvailable]){
						resetServer();
					}
				}
			}
			//删除冗余信息，保证数组长度为2
			delete _.net[status][count-3];
		}
		//记录当此请求使用的服务器地址
		_.net[status][count-1][0] = _.net[currentServer];
	};
	exit.start = function(){
		//标记本次请求成功，不成功的请求数组长度为1
		_.net[status][_.net[total]-1][1] = true;
	};
	_.inject(entry);
	_.inject(exit);
};&lt;/code&gt;&lt;/pre&gt;</content>
 </entry>
 
 <entry>
   <title>AOP in JavaScript</title>
   <link href="http://username.github.com/javascript/2012/03/18/AOP-in-JavaScript"/>
   <updated>2012-03-18T00:00:00+08:00</updated>
   <id>hhttp://username.github.com/javascript/2012/03/18/AOP-in-JavaScript</id>
   <content type="html">&lt;h2 id='id15'&gt;基本概念&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;面向侧面的程序设计&lt;/code&gt;（aspect-oriented programming，AOP，又译作面向方面的程序设计、观点导向编程）是计算机科学中的一个术语，指一种程序设计范型。&lt;/p&gt;

&lt;p&gt;该范型以一种称为侧面（aspect，又译作方面）的语言构造为基础，侧面是一种新的模块化机制，用来描述分散在对象、类或函数中的 &lt;code&gt;横切关注点&lt;/code&gt; （crosscutting concern）。&lt;/p&gt;

&lt;h2 id='id16'&gt;使用目的&lt;/h2&gt;

&lt;p&gt;需要增强或者修改原有函数的功能，但并不直接修改原函数的内部逻辑。比如为函数添加 &lt;code&gt;前置&lt;/code&gt; 和 &lt;code&gt;后置&lt;/code&gt; 操作。&lt;/p&gt;

&lt;p&gt;最常见的应用比如计算函数执行的时间、函数执行时的&lt;code&gt;日志记录&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id='id17'&gt;实际应用&lt;/h2&gt;

&lt;p&gt;在系统中有两个函数，func1和func2，func2是func1代码末尾的JSONP（跨域请求）回调。这两个函数内部逻辑相对复杂，代码也较多。&lt;/p&gt;

&lt;p&gt;func1的执行频率是10秒一次，而客户端与服务器之间的网络并不能保证永远正常连接，除了后端有DNSPOD、反向代理等容灾方案，前端也要做一些容灾工作。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;如何容灾&lt;/code&gt; ？就是在发现连续两次请求失败，就认定主服务器不可用，立刻在前端切换到备用服务器。 确定好这个思路以后剩下的就是在服务端添加各种配置，然后在前端为原有的func1加入请求超时的统计功能。&lt;/p&gt;

&lt;p&gt;超时统计无非就是在func1的开始设置一个变量，func2结束后还原为初始值，如果在指定的超时时间段内发现变量未还原则判定为请求超时。&lt;/p&gt;

&lt;p&gt;这段代码与原函数func1和func2均无逻辑关联，所以尽量不直接修改这2个函数的代码， 加之func1和func2已经相对复杂，若直接修改函数内部代码将导致代码复杂度加倍而且难于维护。&lt;/p&gt;

&lt;p&gt;于是乎，AOP就派上用场了！&lt;/p&gt;

&lt;h2 id='id18'&gt;实现代码&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;var _ = function(id){return document.getElementById(id);};
var GFRAME = {};
GFRAME.name = &amp;#39;GFRAME&amp;#39;;
GFRAME.func1 = function(x){
    console.log(this.name,x);
}
/**
 * @description AOP in JavaScript，不直接修改原函数而增强函数功能。未考虑前置操作的函数返回值的情况
 * @param {Object} args {context:执行环境，name:函数名称，start:前置操作，end:后置操作}
 **/
_.inject = function(args){
    var origin = args.name,
        context = args.context || window,
        start = args.start || (function(){}),
        end = args.end || (function(){});
    var temp = context[origin];
    if(typeof temp != &amp;#39;function&amp;#39;)
        throw Error(origin + &amp;#39; is not a function in the given context.&amp;#39;);
    if(typeof start != &amp;#39;function&amp;#39; || typeof end != &amp;#39;function&amp;#39; )
        throw Error(&amp;#39;start and end is not a function in the given context.&amp;#39;);
    context[origin] = function(){
        start.apply(this,arguments);
        var ret = temp.apply(this,arguments);
        end.apply(this,arguments);
        return ret;
    };
};&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id19'&gt;使用方法&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;_.inject({
    name:&amp;#39;func1&amp;#39;,
    context:GFRAME,
    start:function(x){
        console.log(&amp;#39;start&amp;#39;,this.name,x);
    },
    end:function(x){
        console.log(&amp;#39;end&amp;#39;,this.name,x);
    }
});
GFRAME.func1(&amp;#39;test&amp;#39;);&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id20'&gt;输出结果&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;start GFRAME test
GFRAME test
end GFRAME test &lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id21'&gt;扩展阅读&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href='http://zh.wikipedia.org/wiki/AOP'&gt;AOP@维基百科&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='http://www.cnblogs.com/riceball/archive/2007/09/02/jsInject.html'&gt;你相信么，只需一个函数5行JS代码即可在Javascript中实现完整的AOP功能&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content>
 </entry>
 
 <entry>
   <title>An Easy Template Engine in JavaScript</title>
   <link href="http://username.github.com/javascript/2012/02/06/JavaScript-Template-Engine"/>
   <updated>2012-02-06T00:00:00+08:00</updated>
   <id>hhttp://username.github.com/javascript/2012/02/06/JavaScript-Template-Engine</id>
   <content type="html">&lt;h2 id='id11'&gt;设计目的&lt;/h2&gt;

&lt;p&gt;减少现有代码中的字符串拼接操作，增强代码的可维护性。&lt;/p&gt;

&lt;h2 id='id12'&gt;实现代码&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;/*
 * @description An Easy Template in JavaScript, it is designed to reduce the string concatention work,
 * to make the gigantic code more readable and maintainable.
 */
function Template(tmpl,source){
    //add all template tasks to this array
    this.task = [];
    if(tmpl)
        this.task.push([tmpl,source]);
}
/*
 * @description core function,hanlde two cases: typeof dataSource is either object or array
 *  when the type of dataSource is array,you&amp;#39;d better confirm that the fields in every object is the same.
 */
Template.format = function(template,dataSource){
    //default variable flags
    var start = &amp;#39;{&amp;#39;, end = &amp;#39;}&amp;#39;;
    if(dataSource &amp;amp;&amp;amp; dataSource.slice &amp;amp;&amp;amp; dataSource.length){
        var retStr = [], formatted, len = dataSource.length, regMap = {};
        //restore the RegExp,avoid to construct them repeatedly.
        for(var regKey in dataSource[0]){
            regMap[regKey] = new RegExp(start + regKey + end,&amp;#39;g&amp;#39;);
        }
        for(var index in dataSource){
            formatted = template;
            for(var key in dataSource[index]){
                formatted = formatted.replace(regMap[key],String(dataSource[index][key]));
            }
            retStr.push(formatted);
        }
        return retStr.join(&amp;#39;&amp;#39;);
    }else{
        for(var key in dataSource){
            template = template.replace(new RegExp(start + key + end,&amp;#39;g&amp;#39;),String(dataSource[index][key]));
        }
        return template;
    }
};
Template.prototype.add = function(tmpl,source){
    //add one template task
    this.task.push([tmpl,source]);
};
/*
 * @description handle all tasks,and return the final string.
 *  when this method is invoked,you can reuse the instance.
 */
Template.prototype.end = function(){
    var retStr = [];
    for(var index in this.task){
        retStr.push(Template.format(this.task[index][0],this.task[index][1]));    
    }
    this.task.length = 0;
    return retStr.join(&amp;#39;&amp;#39;);
}; &lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id13'&gt;使用方法&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!doctype html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;script src=&amp;quot;jTemp.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
        &amp;lt;ul id=&amp;quot;MenuItems&amp;quot;&amp;gt;
            &amp;lt;li class=&amp;quot;nav&amp;quot;&amp;gt;&amp;lt;a href=&amp;quot;{href}&amp;quot;&amp;gt;{text}&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;                
        &amp;lt;/ul&amp;gt;
        &amp;lt;script&amp;gt;
            var ul = document.getElementById(&amp;#39;MenuItems&amp;#39;);
            var dataSource = [
                {text:&amp;#39;首页&amp;#39;,href:&amp;#39;http://www.oschina.net/&amp;#39;},
                {text:&amp;#39;开源软件&amp;#39;,href:&amp;#39;http://www.oschina.net/&amp;#39;},
                {text:&amp;#39;讨论区&amp;#39;,href:&amp;#39;http://www.oschina.net/&amp;#39;},
                {text:&amp;#39;代码分享&amp;#39;,href:&amp;#39;http://www.oschina.net/&amp;#39;},
                {text:&amp;#39;资讯&amp;#39;,href:&amp;#39;http://www.oschina.net/&amp;#39;},
                {text:&amp;#39;博客&amp;#39;,href:&amp;#39;http://www.oschina.net/&amp;#39;},
                {text:&amp;#39;Android&amp;#39;,href:&amp;#39;http://www.oschina.net/&amp;#39;}
            ];
            var tmpl = new Template(ul.innerHTML,dataSource);
            ul.innerHTML = tmpl.end();
        &amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id14'&gt;额外说明&lt;/h2&gt;

&lt;p&gt;上面的例子更加偏向于一个简单的HTML的 &lt;code&gt;模板引擎&lt;/code&gt; ，如果这是你需要的，不妨看看 &lt;code&gt;jQuery&lt;/code&gt; 的作者John Resig在几年前的一个 &lt;a href='http://ejohn.org/blog/javascript-micro-templating/'&gt;例子&lt;/a&gt;&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>JSONP Memory Leak</title>
   <link href="http://username.github.com/javascript/2011/10/22/JSONP-Memory-Leak"/>
   <updated>2011-10-22T00:00:00+08:00</updated>
   <id>hhttp://username.github.com/javascript/2011/10/22/JSONP-Memory-Leak</id>
   <content type="html">&lt;h2 id='jsonp'&gt;什么是JSONP？&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;JSONP&lt;/code&gt; （JSON with Padding）是资料格式 JSON 的一种“使用模式”，可以让网页从别的网域要资料。另一个解决这个问题的新方法是跨来源资源共享。&lt;/p&gt;

&lt;p&gt;由于 &lt;code&gt;同源策略&lt;/code&gt; ，一般来说位于 server1.example.com 的网页无法与不是 server1.example.com 的服务器沟通，而 HTML 的 &lt;code&gt;script&lt;/code&gt; 元素是一个例外。利用 script元素的这个开放策略，网页可以得到从其他来源动态产生的 JSON 资料，而这种使用模式就是所谓的 JSONP。用 JSONP 抓到的资料并不是 JSON，而是任意的 JavaScript，用 JavaScript 直译器执行而不是用 JSON 解析器解析。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;来源：&lt;a href='http://zh.wikipedia.org/wiki/JSONP'&gt;JSONP@维基百科&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;简而言之，JSONP就是WEB前端开发中最常用的一种 &lt;code&gt;跨域请求&lt;/code&gt; 数据的方式。&lt;/p&gt;

&lt;h2 id='id6'&gt;使用场景&lt;/h2&gt;

&lt;p&gt;JSONP是一种常用的跨域请求脚本的方式。如果页面不涉及轮询，那也不是什么大问题。但是当页面中存在 &lt;code&gt;轮询&lt;/code&gt; 跨域请求时，问题就被无数倍的放大了。所以需要额外小心由此带来的 &lt;code&gt;内存泄漏&lt;/code&gt;！&lt;/p&gt;

&lt;p&gt;当然毫无疑问，IE系列始终是最让人纠结的。&lt;/p&gt;

&lt;h2 id='id7'&gt;跨域加载脚本&lt;/h2&gt;

&lt;p&gt;通常我们使用下面的方式来加载一段脚本：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var script = document.createElement(&amp;#39;script&amp;#39;);
script.src = &amp;#39;http://www.abc.com/somepage?callback=check&amp;#39;;
script.id = &amp;#39;JSONP&amp;#39;;
var head = document.getElementsByTagName(&amp;#39;head&amp;#39;)[0];
head.appendChild(script);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于一般的WEB应用程序这并不存在什么问题，但是一旦你的应用程序中使用到了轮询，这样只增加节点而不删除，将导致内存不断增长，增长的比例和加载脚本执行的内容也有很大的关系。读者可以尝试向页面不断载入jquery源代码，设定轮询间隔为2s，可以看到内存的增速达到几十M每秒。&lt;/p&gt;

&lt;p&gt;所以十分有必要在脚本执行完成以后删除这些script节点。&lt;/p&gt;

&lt;h2 id='script'&gt;删除加载的script节点&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;var script = document.createElement(&amp;#39;script&amp;#39;);
script.src = &amp;#39;http://www.abc.com/somepage?callback=check&amp;#39;;
script.id = &amp;#39;JSONP&amp;#39;;
script.type = &amp;#39;text/javascript&amp;#39;;
script.charset = &amp;#39;utf-8&amp;#39;;
var head = document.getElementsByTagName(&amp;#39;head&amp;#39;)[0];
head.appendChild(script);
head.removeChild(script);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样的方式可以吗？显然不行！&lt;/p&gt;

&lt;p&gt;因为加载的脚本还没来的及执行就被删除了，所以我们需要 &lt;code&gt;让加载的脚本先执行一会儿&lt;/code&gt; 。&lt;/p&gt;

&lt;h3 id='id8'&gt;曲线救国&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;setTimeout(function(){
	head.removeChild(script);
},200);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不得不说，这样的解决方式很不优雅，要是脚本200ms内还没有执行完毕，肯定会出问题。所以需要保证脚本执行完之后自动删除。&lt;/p&gt;

&lt;h2 id='script'&gt;加载script后自动删除节点&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;var script = document.createElement(&amp;#39;script&amp;#39;);
head.appendChild(script);
if(script.readyState){
	script.onreadysctatechange =function(){
		//注意使用this避免内存泄漏
		if(this.readyState == &amp;#39;completed&amp;#39; || this.readyState == &amp;#39;&amp;#39;loaded)
			this.parentNode.removeChild(this);
	}; 
}else{
	script.onload =function(){
		//注意使用this避免内存泄漏
		this.onload = null;
		this.parentNode.removeChild(this);
	};
}
script.src = url;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;幸好IE支持 &lt;code&gt;onreadysctatechange&lt;/code&gt; 事件，而标准浏览器支持 &lt;code&gt;onload&lt;/code&gt; 事件来判断脚本的执行状态。&lt;/p&gt;

&lt;h2 id='ie'&gt;IE浏览器下的问题&lt;/h2&gt;

&lt;p&gt;那么是不是现在我们的问题就解决了呢？&lt;/p&gt;

&lt;p&gt;测试后发现这样的解决方案不能完全避免内存的不断增长，标准浏览器包括Chrome随着轮询的都会有内存增长的现象， 不过增长程度微乎其微（轮询间隔2m，增长速度也只有4k-8k）。但是IE会有十几到几十K的内存增长。&lt;/p&gt;

&lt;p&gt;你会看到我们在script加载完成之后已经将script元素删除了，为什么内存还会不断增长呢？&lt;/p&gt;

&lt;p&gt;很简单，这就是 &lt;code&gt;内存泄漏&lt;/code&gt; 现象。&lt;/p&gt;

&lt;h2 id='script'&gt;重用script节点&lt;/h2&gt;

&lt;p&gt;标准浏览器对script标签的处理就是每个script标签的地址（src）只能设置一次， 后续的设置能够改变地址，但是对应地址的脚本内容不会执行，不管script标签是页面预留的还是动态插入。&lt;/p&gt;

&lt;p&gt;IE下面则很神奇，使用js动态插入的script标签不遵守这一规则。 于是我们只需要动态的插入一个id已知的script标签，然后不断地改变它的src，以此方式加载的脚本都会执行。 而且这个script节点也不必删除，下次请求继续重用即可。&lt;/p&gt;

&lt;p&gt;这样IE下面的内存泄漏问题就解决了！&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var _ = function(id){return document.getElementById(id);};
_.ajax = function(){};
(function(){
    //存储超时或异常的JSONP请求
    _.ajax.TIMEOUT_REQUEST = [];
	//超时设定
	_.ajax.TIMEOUT = 5000;
	if(_.isIE){
		//JSONP重用标签的id
		_.ajax.SCRIPT_ID = &amp;#39;ie_script_for_jsonp&amp;#39;;
		//重用标签是否被JSONP请求占用
		_.ajax.SCRIPT_USED = false;
		//被占用时JSONP请求等待的时间
		_.ajax.WAIT_TIME = 100;
		//上次JSONP请求的时间
		_.ajax.LAST_USED_TIME = 0;
		var script = document.createElement(&amp;#39;script&amp;#39;), head = document.head || document.getElementsByTagName(&amp;#39;head&amp;#39;)[0];
		script.setAttribute(&amp;#39;id&amp;#39;,_.ajax.SCRIPT_ID);
		script.onreadystatechange = function(){
			if (this.readyState == &amp;quot;loaded&amp;quot; || this.readyState == &amp;quot;complete&amp;quot;){
				_.ajax.SCRIPT_USED = false;
			}
		};
		head.appendChild(script);
	}
})();
/**
 * @description 轮询JSONP请求调用，IE浏览器采用重用Script节点方式。
 * @param url 手动加上callback参数，自动追加了时间戳
 **/
_.ajax.jsonp = function(url){
	if(!navigator.onLine){
		_.ajax.TIMEOUT_REQUEST.push(url);
		return;
	}
	var script, now = new Date().getTime(), 
		requestUrl = url + (url.indexOf(&amp;#39;?&amp;#39;)&amp;gt;-1?&amp;#39;&amp;amp;timestamp=&amp;#39;:&amp;#39;?timestamp=&amp;#39;) + now,
		head = document.head || document.getElementsByTagName(&amp;#39;head&amp;#39;)[0];
	if(_.isIE &amp;amp;&amp;amp; _.isIE &amp;lt; 9){
		script = document.getElementById(_.ajax.SCRIPT_ID);
		//节点被占用
		if(_.ajax.SCRIPT_USED){
			if(_.ajax.LAST_USED_TIME === 0)
				_.ajax.LAST_USED_TIME = now;
			//已经超时
			if((now - _.ajax.LAST_USED_TIME) &amp;gt; _.ajax.TIMEOUT){
				_.ajax.LAST_USED_TIME = now;
				if(_.ajax.TIMEOUT_REQUEST.length&amp;gt;=1000)
					_.ajax.TIMEOUT_REQUEST.length = 0;
				_.ajax.TIMEOUT_REQUEST.push(script.src.split(&amp;#39;&amp;amp;timestamp=&amp;#39;)[0]);
				script.src = requestUrl;
			//没有超时则等待
			}else{
				setTimeout(function(){_.ajax.jsonp(url);},_.ajax.WAIT_TIME);
			}
		}else{
			_.ajax.SCRIPT_USED = true;
			_.ajax.LAST_USED_TIME = now;
			script.src = requestUrl;
		}
	}else{
		script = document.createElement(&amp;#39;script&amp;#39;);
		head.appendChild(script);
		script.onload =	function(){
			this.onload = null;
			this.parentNode.removeChild(this);
		};
        script.onerror = function(){
            _.ajax.TIMEOUT_REQUEST.push(this.src);
        };
		script.src = requestUrl;
	}
};&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id9'&gt;测试结果&lt;/h2&gt;

&lt;p&gt;对上述代码测试，使用 &lt;code&gt;sieve&lt;/code&gt; 结合任务管理器，发现此方法引起的内存泄漏和chrome下面的差不多都在4K左右，测试环境是IE 8。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var i = 0;
window.onload = function(){
	setInterval(function(){
		_.ajax.jsonp(&amp;#39;data.js&amp;#39;);
	},1000);
};&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;data.js 的内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;i++; &lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id10'&gt;后续说明&lt;/h2&gt;

&lt;p&gt;其实之所以存在内存泄漏，是因为IE的 &lt;code&gt;removeChild&lt;/code&gt; 方法存在内存泄漏的问题。对于这一点 &lt;code&gt;jQuery&lt;/code&gt; 的 &lt;code&gt;empty&lt;/code&gt; 方法已经考虑到。关于removeChild导致内存泄漏的问题，很早就被发现了，具体请看&lt;a href='http://groups.google.com/group/jquery-dev/browse_thread/thread/4a99f6e9b2e33057/45ce657a48afd43a?pli=1'&gt;这里&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;一般的框架都有各自的删除节点的方式来避免内存泄漏问题，下面是 &lt;code&gt;EXT&lt;/code&gt; 的处理方式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;_.dom = function(){};
/**
 * @description 采用ext的处理方式，也可以对删除的元素使用outerHTML=&amp;#39;&amp;#39;，但是此方法不通用，某些元素的outerHTML属性只读
 * @param n 要删除的HTML节点
 */
_.dom.remove = function(n){
	var d;
	if(_.isIE){
        if(n &amp;amp;&amp;amp; n.tagName != &amp;#39;BODY&amp;#39;){
            d = d || document.createElement(&amp;#39;div&amp;#39;);
            d.appendChild(n);
            d.innerHTML = &amp;#39;&amp;#39;;
        }
	}else{
	    if(n &amp;amp;&amp;amp; n.parentNode &amp;amp;&amp;amp; n.tagName != &amp;#39;BODY&amp;#39;){
	        n.parentNode.removeChild(n);
	    }
	}
};&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为什么jQuery的 &lt;code&gt;getJSON&lt;/code&gt; 在进行跨域请求时仍然存在比较严重的内存泄漏？或许是script节点不同于普通的html元素吧，无法按照上述方式删除吧。&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Dimensions of Elements</title>
   <link href="http://username.github.com/javascript/2011/09/26/Dimensions-of-Elements"/>
   <updated>2011-09-26T00:00:00+08:00</updated>
   <id>hhttp://username.github.com/javascript/2011/09/26/Dimensions-of-Elements</id>
   <content type="html">&lt;p&gt;&lt;strong&gt;在使用JavaScript脚本获取 &lt;code&gt;元素的尺寸&lt;/code&gt; 时，有几个属性你需要弄清楚，不然会很棘手。以往我都是对这些属性死记硬背，忘记了就查手册。看完本文我相信这种情况就不会再发生了.&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id='id1'&gt;元素占据的物理空间的尺寸&lt;/h2&gt;

&lt;p&gt;如果你需要获得元素占据的物理空间，那么使用 &lt;code&gt;ffsetHeight&lt;/code&gt; 和 &lt;code&gt;offsetWidth&lt;/code&gt; 。 自然而然此物理空间必然包含的有：&lt;code&gt;padding&lt;/code&gt; 、&lt;code&gt;滚动条&lt;/code&gt; 、&lt;code&gt;border&lt;/code&gt;。这两个属性与 &lt;code&gt;getBoundingClientRect()&lt;/code&gt;的height和width属性是一致的。&lt;/p&gt;

&lt;p&gt;为了帮助理解请看下图：&lt;/p&gt;

&lt;p&gt;&lt;img src='https://developer.mozilla.org/@api/deki/files/186/=Dimensions-offset.png' alt='Alt text' /&gt;&lt;/p&gt;

&lt;h2 id='id2'&gt;元素内部内容的可视区域的尺寸&lt;/h2&gt;

&lt;p&gt;可视区域包含padding，但是不包含border、滚动条。此时请使用 &lt;code&gt;clientHeight&lt;/code&gt; 和 &lt;code&gt;clientWidth&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;为了帮助理解请看下图：&lt;/p&gt;

&lt;p&gt;&lt;img src='https://developer.mozilla.org/@api/deki/files/185/=Dimensions-client.png' alt='Alt text' /&gt;&lt;/p&gt;

&lt;h2 id='id3'&gt;元素内部内容的全部尺寸&lt;/h2&gt;

&lt;p&gt;如果你要获取元素内容的真正大小，当然也包含那些不可见的内容，此时你需要使用 &lt;code&gt;scrollHeight&lt;/code&gt; / &lt;code&gt;scrollWidth&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;例如一张600&lt;em&gt;400的图片被包含在一个300&lt;/em&gt;300的可滚动的容器元素内，那么scrollWidth将返回600，而scrollHeight将返回400&lt;/p&gt;

&lt;h2 id='id4'&gt;获取元素的真实尺寸&lt;/h2&gt;

&lt;p&gt;大部分场景，我们并不关心元素的全部内容的尺寸（window/document/body元素除外），最常用的恐怕还是获取元素占据的物理空间(offsetHeight/offsetWidth)。&lt;/p&gt;

&lt;p&gt;比如对某段文字设置自定义的tooltip，这个时候需要获取目标元素的高度然后对tooltip进行定位。&lt;/p&gt;

&lt;p&gt;不论是clientHeight还是offsetHeight它们都包含了padding，假设这段文字包含了100px的padding，这个tooltip的位置显然会极其的不准确。&lt;/p&gt;

&lt;p&gt;因此获取元素的高度通常是需要去掉padding。&lt;/p&gt;

&lt;p&gt;由于元素的style属性只能获取到内联样式的width/height，所以在IE中需要使用 &lt;code&gt;el.currentStyle.height/width&lt;/code&gt;， 而标准浏览器中使用 &lt;code&gt;window.getComputedStyle(el,null).width/height&lt;/code&gt;。 下面是我整理的园友Snandy的一个用户获取元素真实高度和宽度的方法 :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function getStyle(el) {
    if(window.getComputedStyle) {
        return window.getComputedStyle(el, null);
    }else{
        return el.currentStyle;
    }
}
function getWH(el, name) {
    var val = name === &amp;quot;width&amp;quot; ? el.offsetWidth : el.offsetHeight,
        which = name === &amp;quot;width&amp;quot; ? [&amp;#39;Left&amp;#39;, &amp;#39;Right&amp;#39;] : [&amp;#39;Top&amp;#39;, &amp;#39;Bottom&amp;#39;];
    // display is none
    if(val === 0) {
        return 0;
    }
    var style = getStyle(el);
    for(var i = 0, a; a = which[i++];) {
        val -= parseFloat( style[&amp;quot;border&amp;quot; + a + &amp;quot;Width&amp;quot;]) || 0;
        val -= parseFloat( style[&amp;quot;padding&amp;quot; + a ] ) || 0;
    }
    return val;
 } &lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id='jquery'&gt;jQuery与元素尺寸相关的方法&lt;/h2&gt;

&lt;h3 id='jqueryheightjquerywidth'&gt;jQuery.height()/jQuery.width()&lt;/h3&gt;

&lt;p&gt;返回一个整数，为匹配的jQuery对象集合中第一个元素的高度值。 注意此结果不关心盒式模型，不包含元素的padding。此方法等价于getWH(el,&amp;#8217;height/width&amp;#8217;) 这个方法同样能计算出window和document的高度。&lt;/p&gt;

&lt;h3 id='jqueryinnerheightjqueryinnerwidth'&gt;jQuery.innerHeight()/jQuery.innerWidth()&lt;/h3&gt;

&lt;p&gt;对比jQuery.height() /jQuery.width() 此结果包含padding，但是不包含border。 当元素el未设置border时，此方法等价于el.offsetHeight/offsetWidth&lt;/p&gt;

&lt;h3 id='jqueryouterheightjqueryouterwidth'&gt;jQuery.outerHeight()/jQuery.outerWidth()&lt;/h3&gt;

&lt;p&gt;对比jQuery.height() /jQuery.width() 此结果包含padding和border，默认不包含margin。 当元素未指定margin时，此方法等价于el.offsetHeight/offsetWidth 可以传入一个bool变量来指定是否包含margin。&lt;/p&gt;

&lt;p&gt;注意： 由于获取普通元素的全部内容的尺寸意义不大（某些元素除外如window、document、iframe等）， 所以jQuery的这三个方法都未包含不可见区域。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id='id5'&gt;参考阅读&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href='http://www.cnblogs.com/snandy/archive/2011/09/06/2167440.html'&gt;各情景下元素宽高的获取 by Snandy&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='https://developer.mozilla.org/en/Determining_the_dimensions_of_elements'&gt;Determining the dimensions of elements&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='http://msdn.microsoft.com/en-us/library/ms530302(VS.85'&gt;Measuring Element Dimension and Location with CSSOM in Internet Explorer 9&lt;/a&gt;.aspx)&lt;/li&gt;
&lt;/ul&gt;</content>
 </entry>
 
 
</feed>