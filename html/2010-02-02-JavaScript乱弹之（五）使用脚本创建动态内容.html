<!doctype html>
<html>
<head>
	<meta charset="utf-8"/>
	<meta name="description" content="JavaScript乱弹之（五）使用脚本创建动态内容 @ 2010-02-02"/>
	<title>JavaScript乱弹之（五）使用脚本创建动态内容 @ 2010-02-02</title>
	<link rel="shortcut icon" href="https://cdn1.iconfinder.com/data/icons/bitcoin-casino-coins/32/CoinSphere-Bitcoin-Green-Casino-Chip-32.png" />
	<link rel="stylesheet" href="../lib/prism/prism.css"/>
	<link rel="stylesheet" href="../themes/darcula/index.css"/>
</head>
<body>
	<h1 id="javascript-">JavaScript乱弹之（五）使用脚本创建动态内容</h1>
<h2 id="document-write-">document.write()</h2>
<p>所有支持脚本的浏览器都可以在正文中嵌入document.write()语句。利用它你可以动态的创建内容，不过使用它你需要十分小心。最常见的错误就是在页面加载完毕以后调用，以修改或向页面添加内容。这样的结果只会是用你组装的脚本内容替换掉你的当前页。</p>
<h2 id="-">创建节点</h2>
<p>创建动态内容标准的方法是使用W3C的document对象的元素创建方法。</p>
<pre><code class="lang-js">var elem=document.createElement(&quot;p&quot;);
//参数名可以是大写也可以是小写，但是元素elem.tagName的返回值永远是大写。
createAttribute( attributeName )
createComment( commentString )
createDocumentFragment()
createTextNode( textString )
</code></pre>
<p>以上方法全部返回一个节点对象（node object），在没有进行插入操作时，以上方法并不影响DOM的结构。</p>
<h2 id="-">插入和附加节点</h2>
<p><strong>insertBefore( newChildNode, referenceNode )</strong></p>
<p>在现有的子节点前插入一个节点
使用方法：parentnode.insertBefore(newNode,childnode)，当childnode为null时作用与appendChild相同。</p>
<p><strong>appendChild( newChildNode )</strong></p>
<p>将节点添加到指定的节点的最后一个子节点的后面
使用方法：parentnode.appendChild(newNode);</p>
<h2 id="-">移除、替换和复制节点</h2>
<p><strong>removeChild( childNode )</strong></p>
<p><strong>replaceChild( newNode, nodeToReplace )</strong></p>
<p><strong>cloneNode( true/false)</strong></p>
<p>True表示深克隆，所有子节点也被克隆；false表示浅克隆，不会复制子节点。
设置节点的属性</p>
<p>有两种常用的方式：</p>
<pre><code class="lang-js">var elem=document.createElement(&quot;div&quot;);
elem.setAttribute(&quot;id&quot;,&quot;testDIV&quot;);
elem[&quot;id&quot;]=&quot;testDIV&quot;;
</code></pre>
<p>浏览器能够同等识别以上两种方法，W3C推荐第一种，但是由于第一种在IE经常无法改变属性的值，所以最好还是用第二种。</p>
<p><strong>innerHTML</strong></p>
<p>IE4引入了两个基于文本的元素对象属性：<strong>innerText</strong>和<strong>innerHTML</strong>，由于innerHTML的大量使用而且实用性很强，以至于原本那些许多以“标准”自居的浏览器在严格遵守
W3C DOM戒律方面有所放宽，并实现了innerHTML。FireFox并不支持innerText。
请你记住innerHTML的开创者是IE！</p>
<p>节点的常用属性</p>
<blockquote>
<ul>
<li>nodeName</li>
<li>nodeValue</li>
<li>nodeType</li>
<li>parentNode</li>
<li>childNodes</li>
<li>Attributes</li>
<li>firstChild</li>
<li>lastChild</li>
<li>ownerDocument</li>
<li>previousSibling</li>
<li>nextSibling</li>
<li>tagName</li>
</ul>
</blockquote>
<h1 id="nodetype-">nodeType对应值与类型</h1>
<blockquote>
<ul>
<li>1 Element</li>
<li>2 Attribute</li>
<li>3 Text</li>
<li>8 Comment</li>
<li>9 Document</li>
<li>10 DocumentType</li>
</ul>
</blockquote>
<p>自定义的insertAfter方法</p>
<pre><code class="lang-js">function insertAfter(newEl, targetEl){
            var parentEl = targetEl.parentNode;
                        if(parentEl.lastChild == targetEl)
            {
                parentEl.appendChild(newEl);
            }else
            {
                parentEl.insertBefore(newEl,targetEl.nextSibling);
            }            
}
</code></pre>
<p>思路：首先找到目标节点的父节点，如果目标节点是父节点的最后一个子节点，则使用appendChild方法；如果不是最后一个节点则使用JavaScript内置的insertBefore方法插入到目标节点的下一个兄弟节点之前。</p>
<p>使用方法：</p>
<pre><code class="lang-js">var txtName = document.getElementById(&quot;txtName&quot;);
var htmlSpan = document.createElement(&quot;span&quot;);
htmlSpan.innerHTML = &quot;This is a test&quot;;
insertAfter(htmlSpan,txtName);
</code></pre>
<p>将htmlSpan 作为txtName 的兄弟节点插入到txtName 节点之后</p>

	<script src="../lib/prism/prism.js"></script>
</body>
</html>