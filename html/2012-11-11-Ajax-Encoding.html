<!doctype html>
<html>
<head>
	<meta charset="utf-8"/>
	<meta name="description" content="Ajax Encoding @ 2012-11-11"/>
	<title>Ajax Encoding @ 2012-11-11</title>
	<link rel="shortcut icon" href="https://cdn1.iconfinder.com/data/icons/bitcoin-casino-coins/32/CoinSphere-Bitcoin-Green-Casino-Chip-32.png" />
	<link rel="stylesheet" href="../lib/prism/prism.css"/>
	<link rel="stylesheet" href="../themes/darcula/index.css"/>
</head>
<body>
	<h1 id="ajax-">Ajax编码问题</h1>
<hr>
<p>前些天看到一个关于Ajax编码的问题，当时被提问者的描述绕的都想不清楚，今天闲来没事就整理下。原文地址在<a href="http://segmentfault.com/q/1010000000130593">这里</a>。</p>
<h2 id="-">问题描述</h2>
<p>我的前端页面为GBK，所以待发送的数据肯定也为GBK，而由ajax的特性其在发送前其会被自动转换为utf-8
所以后台接收到的数据为utf-8的
然后我的后台页面编码为UTF-8，同时设置了response header中的编码参数也为UTF-8，那么前端收到的数据应该也是UTF-8
但前端页面为GBK，理论上来说这样会产生乱码，可是并没有，这是为什么呢？</p>
<p>提问者的描述有点混乱，而且各种绕，一不小心就会踩到提问者设的坑。</p>
<h2 id="-">如何解决</h2>
<p>彻底解决这个问题你首先需要了解以下几个知识点：</p>
<blockquote>
<ul>
<li>页面表单提交到后台的数据编码与页面编码一致</li>
<li>通过javascript提交到后台的数据都会被转换为utf-8格式</li>
</ul>
</blockquote>
<p>所以原则上这样理解，这个问题就差不多了：</p>
<pre><code>输入编码为UTF-8，后台以UTF-8方式输出，保证输入和输出一致那么自然就没有乱码问题。
</code></pre><p>要让别人相信自己，首先得自己相信自己，我们先不妨来几个测试。另外问题描述既然提到了后台的文本编码，我们也需要重点测试一下。</p>
<h2 id="-">测试工作</h2>
<p>准备以下页面：</p>
<ul>
<li>主页面index.php</li>
<li>ajax后台页面utf8.php</li>
<li>ajax后台页面gbk.php</li>
</ul>
<h3 id="-index-php-gbk">主页面 index.php，文本编码gbk</h3>
<pre><code class="lang-html">    &lt;!doctype html&gt;
    &lt;html&gt;
        &lt;head&gt;
            &lt;meta charset=&quot;gbk&quot;/&gt;
            &lt;script src=&quot;http://s.segmentfault.com/js/jquery.js?12.11.5.1&quot;&gt;&lt;/script&gt;
        &lt;/head&gt;    
        &lt;body&gt;
            &lt;button type=&quot;button&quot; onclick=&quot;ajax_send(&#39;utf8&#39;)&quot;&gt;JS提交(utf-8)&lt;/button&gt;
            &lt;button type=&quot;button&quot; onclick=&quot;ajax_send(&#39;gbk&#39;)&quot;&gt;JS提交(gbk)&lt;/button&gt;
            &lt;script type=&quot;text/javascript&quot;&gt;
                var ajax_send = function(encoding){
                    var xhr = new XMLHttpRequest(), params = encodeURI(&#39;t=编码&#39;)
                    xhr.onreadystatechange = function(){
                        if(this.readyState == 4 &amp;&amp; this.status ==200)
                            alert(this.responseText)
                    }
                    xhr.open(&#39;POST&#39;,encoding + &#39;.php&#39;,true)
                    xhr.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;);
                    xhr.send(params)
                }
            &lt;/script&gt;
        &lt;/body&gt;
</code></pre>
<h3 id="utf8-php-utf-8">utf8.php，文本编码utf-8</h3>
<pre><code class="lang-php">    &lt;?php
    header(&#39;content-type:text/html;charset=utf-8&#39;);
    echo $_POST[&#39;t&#39;];
    ?&gt;
</code></pre>
<h3 id="gbk-php-utf8-php-gbk">gbk.php，与utf8.php内容相同，区别就是文本编码为gbk</h3>
<pre><code class="lang-php">    &lt;?php
    header(&#39;content-type:text/html;charset=utf-8&#39;);
    echo $_POST[&#39;t&#39;];
    ?&gt;
</code></pre>
<p>启动Web Server，打开页面，分别点击按钮，都正确的弹出了“编码”二字，没有发现乱码现象。</p>
<h2 id="-">结论</h2>
<p>对于页面通过JS提交的数据：</p>
<blockquote>
<ul>
<li>后台接口，只要保证输入输出的编码一致，提交的数据就会有乱码产生</li>
<li>后台文件的文本编码以及前端页面的编码不会导致提交的数据返回时乱码，只要输入输出编码一致</li>
</ul>
</blockquote>
<p>对于以上两个结论，读者还可以这样测试。</p>
<pre><code class="lang-php">    &lt;?php
    header(&#39;content-type:text/html;charset=gbk&#39;);
    echo iconv(&quot;utf-8&quot;,&quot;gbk&quot;,$_POST[&#39;t&#39;]);
    ?&gt;
</code></pre>
<p>先将输入转码为gbk，然后输出同时设置为页面编码，这样也不会有乱码产生，但是服务端多了一道转码处理，效率不及直接输出utf-8。</p>
<p>对于后台附加的一些输出，比如在gbk.php中最后加一行</p>
<pre><code class="lang-php">    echo &quot;中文&quot;;
</code></pre>
<p>这种情况会不会导致乱码呢？读者可以自己测试一下。</p>
<h2 id="-">深入</h2>
<p>稍微搞过前端的人都知道，使用script标签引入脚本的时候，有一个属性是charset用于指定脚本文件的编码。当页面编码与引入脚本的文本编码不一致的时候需要显式指定，否则就会容易造成乱码。</p>
<p>现在我们仔细对比这两种场景的处理方式，不就是一模一样吗？只要保证输入输出的编码一致即可。唯一的区别就是一个是静态资源，一个是动态接口。</p>
<p>你有可能会问，当输入输出指定的编码不一致时是不是就一定是乱码呢，浏览器又该如何解析呢？</p>
<p>这个时候你就该来<a href="http://ued.taobao.com/blog/2011/08/26/encode-war/">这里</a>看看了。</p>
<p>光棍节写博客，看来我是真光棍，真屌丝。</p>

	<script src="../lib/prism/prism.js"></script>
</body>
</html>